from argparse import Namespace
from typing import Any

from gallia.command import UDSScanner
from gallia.log import get_logger
from gallia.services.uds import (
    NegativeResponse,
    UDSErrorCodes,
    UDSIsoServices,
    UDSRequestConfig,
    UDSResponse,
)
from gallia.services.uds.core.exception import MalformedResponse, UDSException
from gallia.services.uds.core.utils import g_repr
from gallia.utils import ParseSkips, auto_int

logger = get_logger(__name__)

class VulnerabilityScanner(UDSScanner):
    """Iterate sessions and services to find vulnerabilities"""

    COMMAND = "vulnerabilities"
    SHORT_HELP = "vulnerability scan on an ECU"
    EPILOG = "asdf"

    async def main(self, args: Namespace) -> None:
        self.result: list[tuple[int, int]] = []
        self.ecu.max_retry = 1
        found: dict[int, dict[int, Any]] = {}

        # if args.sessions is None:
        found[0] = await self.unauthorized_ecu_reset(args)
        # else:
        #     sessions = [s for s in args.sessions if s not in args.skip or args.skip[s] is not None]
        #     logger.info(f"testing sessions {g_repr(sessions)}")

        #     # TODO: Unified shortened output necessary here
        #     logger.info(f"skipping identifiers {reprlib.repr(args.skip)}")

        #     for session in sessions:
        #         logger.info(f"Changing to session {g_repr(session)}")
        #         try:
        #             resp: UDSResponse = await self.ecu.set_session(
        #                 session, UDSRequestConfig(tags=["preparation"])
        #             )
        #         except (
        #             UDSException,
        #             RuntimeError,
        #         ) as e:  # FIXME why catch RuntimeError?
        #             logger.warning(
        #                 f"Could not complete session change to {g_repr(session)}: {g_repr(e)}; skipping session"
        #             )
        #             continue
        #         if isinstance(resp, NegativeResponse):
        #             logger.warning(
        #                 f"Could not complete session change to {g_repr(session)}: {resp}; skipping session"
        #             )
        #             continue

        #         logger.result(f"scanning in session {g_repr(session)}")

        #         found[session] = await self.perform_scan(args, session)

        #         await self.ecu.leave_session(session, sleep=args.power_cycle_sleep)

        for key, value in found.items():
            #logger.result(f"findings in session 0x{key:02X}:")
            logger.result(f"findings in duulga 0x{key}:")
            # for sid, data in value.items():
            #     self.result.append((key, sid))
            #     try:
            #         logger.result(f"  [{g_repr(sid)}] {UDSIsoServices(sid).name}: {data}")
            #     except Exception:
            #         logger.result(f"  [{g_repr(sid)}] vendor specific sid: {data}")

    async def unauthorized_ecu_reset(self, args: Namespace, session: None | int = None) -> dict[int, Any]:
        # Try ECU reset on non-default sessions
        result: dict[int, Any] = {}
        # Hard Reset
        message = [0x11, 0x01]
                
        # Try adding 2 null bytes because my gut tells to do
        pdu = bytes(message) + bytes(len(message))

        try:
            resp = await self.ecu.send_raw(pdu, config=UDSRequestConfig(tags=["ANALYZE"]))
        except TimeoutError:
            logger.info(f"{g_repr(message)}: timeout")

        except MalformedResponse as e:
            logger.warning(f"{g_repr(message)}: {e!r} occurred, this needs to be investigated!")

        if isinstance(resp, NegativeResponse) and resp.response_code in [
            UDSErrorCodes.serviceNotSupported,
            UDSErrorCodes.serviceNotSupportedInActiveSession,
        ]:
            logger.info(f"{g_repr(message)}: not supported [{resp}]")

        if isinstance(resp, NegativeResponse) and resp.response_code in [
            UDSErrorCodes.incorrectMessageLengthOrInvalidFormat,
        ]:
            logger.info('Vulnerability Scanner')

        logger.result(f"{g_repr(message)}: available in session {g_repr(session)}: {resp}")

        result = resp
        return result